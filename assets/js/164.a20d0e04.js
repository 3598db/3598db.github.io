(window.webpackJsonp=window.webpackJsonp||[]).push([[164],{520:function(a,t,v){"use strict";v.r(t);var _=v(42),r=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"v8工作原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v8工作原理"}},[a._v("#")]),a._v(" 🤔V8工作原理")]),a._v(" "),v("p"),v("div",{staticClass:"table-of-contents"},[v("ul",[v("li",[v("a",{attrs:{href:"#堆空间和栈空间"}},[a._v("堆空间和栈空间")])]),v("li",[v("a",{attrs:{href:"#栈垃圾回收"}},[a._v("栈垃圾回收")])]),v("li",[v("a",{attrs:{href:"#代际假说"}},[a._v("代际假说")])]),v("li",[v("a",{attrs:{href:"#分类"}},[a._v("分类")]),v("ul",[v("li",[v("a",{attrs:{href:"#新生代"}},[a._v("新生代")])]),v("li",[v("a",{attrs:{href:"#老生代"}},[a._v("老生代")])])])]),v("li",[v("a",{attrs:{href:"#_1-生成抽象语法树-ast-和执行上下文"}},[a._v("1. 生成抽象语法树(AST)和执行上下文")])]),v("li",[v("a",{attrs:{href:"#_2-生成字节码"}},[a._v("2. 生成字节码")])]),v("li",[v("a",{attrs:{href:"#_3-执行代码"}},[a._v("3. 执行代码")])])])]),v("p"),a._v(" "),v("h1",{attrs:{id:"javascript是什么类型的语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javascript是什么类型的语言"}},[a._v("#")]),a._v(" JavaScript是什么类型的语言")]),a._v(" "),v("p",[a._v("JavaScript是一种弱类型的、动态的语言")]),a._v(" "),v("ul",[v("li",[a._v("动态：我们把这种在使用之前就需要确认其变量数据类型的称为静态语言。相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言。")]),a._v(" "),v("li",[a._v("弱类型：支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。")])]),a._v(" "),v("h1",{attrs:{id:"javascript的数据类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javascript的数据类型"}},[a._v("#")]),a._v(" JavaScript的数据类型")]),a._v(" "),v("p",[a._v("数据类型（8种）：")]),a._v(" "),v("ol",[v("li",[v("code",[a._v("Boolean")])]),a._v(" "),v("li",[v("code",[a._v("Null")])]),a._v(" "),v("li",[v("code",[a._v("Undefined")])]),a._v(" "),v("li",[v("code",[a._v("Number")])]),a._v(" "),v("li",[v("code",[a._v("Biglnt")])]),a._v(" "),v("li",[v("code",[a._v("String")])]),a._v(" "),v("li",[v("code",[a._v("Symbol")])]),a._v(" "),v("li",[v("code",[a._v("Object")])])]),a._v(" "),v("h1",{attrs:{id:"内存空间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存空间"}},[a._v("#")]),a._v(" 内存空间")]),a._v(" "),v("p",[a._v("在JavaScript的执行过程中，主要有三种类型内存空间，分别是代码空间，栈空间和堆空间。")]),a._v(" "),v("h2",{attrs:{id:"堆空间和栈空间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆空间和栈空间"}},[a._v("#")]),a._v(" 堆空间和栈空间")]),a._v(" "),v("p",[a._v("调用栈存放的是全局上下文，函数执行上下文。")]),a._v(" "),v("p",[a._v("在构建函数执行上下文的过程中，会初始化：")]),a._v(" "),v("ol",[v("li",[a._v("词法环境：主要存放的是块级作用域声明变量；")]),a._v(" "),v("li",[a._v("变量环境：存放的是var变量声明，outer指针会指向外层执行上下文；")]),a._v(" "),v("li",[a._v("this指向；")])]),a._v(" "),v("blockquote",[v("p",[a._v("对于闭包而言，如果发现内部函数引用了外部函数的变量，将会在堆空间中创建一个closure(fn)的闭包对象。")])]),a._v(" "),v("h2",{attrs:{id:"栈垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈垃圾回收"}},[a._v("#")]),a._v(" 栈垃圾回收")]),a._v(" "),v("p",[a._v("当函数执行结束，JS引擎通向下移动ESP指针（记录调用栈当前执行状态的指针），来销毁该函数保存在栈中的执行上下文（变量环境、词法环境、this、outer）。")]),a._v(" "),v("h1",{attrs:{id:"堆垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆垃圾回收"}},[a._v("#")]),a._v(" 堆垃圾回收")]),a._v(" "),v("h2",{attrs:{id:"代际假说"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#代际假说"}},[a._v("#")]),a._v(" 代际假说")]),a._v(" "),v("ol",[v("li",[a._v("大部分对象存活时间很短")]),a._v(" "),v("li",[a._v("不被销毁的对象，会活的更久")])]),a._v(" "),v("h2",{attrs:{id:"分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[a._v("#")]),a._v(" 分类")]),a._v(" "),v("p",[a._v("V8中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。")]),a._v(" "),v("h3",{attrs:{id:"新生代"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#新生代"}},[a._v("#")]),a._v(" 新生代")]),a._v(" "),v("p",[a._v("算法：Scavenge算法")]),a._v(" "),v("p",[a._v("原理：")]),a._v(" "),v("ol",[v("li",[a._v("把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。")]),a._v(" "),v("li",[a._v("新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。")]),a._v(" "),v("li",[a._v("先对对象区域中的垃圾做标记，标记完成之后，把这些存活的对象复制到空闲区域中")]),a._v(" "),v("li",[a._v("完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。")])]),a._v(" "),v("p",[a._v("对象晋升策略：经过两次垃圾回收依然还存活的对象，会被移动到老生区中。")]),a._v(" "),v("h3",{attrs:{id:"老生代"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#老生代"}},[a._v("#")]),a._v(" 老生代")]),a._v(" "),v("p",[a._v("算法：标记-清除(Mark-Sweep)算法")]),a._v(" "),v("p",[a._v("原理：")]),a._v(" "),v("ol",[v("li",[a._v("标记：标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。")]),a._v(" "),v("li",[a._v("清除：将垃圾数据进行清除。\n碎片：对一块内存多次执行标记-清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存。")])]),a._v(" "),v("p",[a._v("算法：标记-整理(Mark-Compact)算法\n原理：")]),a._v(" "),v("ol",[v("li",[a._v("标记：和标记-清除的标记过程一样，从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素标记为活动对象。")]),a._v(" "),v("li",[a._v("整理：让所有存活的对象都向内存的一端移动")]),a._v(" "),v("li",[a._v("清除：清理掉端边界以外的内存")])]),a._v(" "),v("p",[a._v("优化算法：增量标记(Incremental Marking)算法\n原理：")]),a._v(" "),v("ol",[v("li",[a._v("为了降低老生代的垃圾回收而造成的卡顿")]),a._v(" "),v("li",[a._v("V8把一个完整的垃圾回收任务拆分为很多小的任务")]),a._v(" "),v("li",[a._v("让垃圾回收标记和JavaScript应用逻辑交替进行，长时间的停顿可能会导致应用程序无法响应，并导致用户体验不佳。2011年，V8从stop-the-world标记切换到增量标志。在增量标记期间，GC将标记工作分解为更小的模块，并允许应用程序在模块之间运行。")])]),a._v(" "),v("h1",{attrs:{id:"编译器和解释器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#编译器和解释器"}},[a._v("#")]),a._v(" 编译器和解释器")]),a._v(" "),v("p",[a._v("编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。")]),a._v(" "),v("h1",{attrs:{id:"v8是如何执行一段javascript代码的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v8是如何执行一段javascript代码的"}},[a._v("#")]),a._v(" V8是如何执行一段JavaScript代码的")]),a._v(" "),v("p",[a._v("解释器Ignition (点火器) 编译器TurboFan (涡轮层压)")]),a._v(" "),v("h2",{attrs:{id:"_1-生成抽象语法树-ast-和执行上下文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-生成抽象语法树-ast-和执行上下文"}},[a._v("#")]),a._v(" 1. 生成抽象语法树(AST)和执行上下文")]),a._v(" "),v("ol",[v("li",[a._v("第一阶段是分词(tokenize)，又称为词法分析，其作用是将一行行的源码拆解成一个个token。")]),a._v(" "),v("li",[a._v("第二阶段是解析(parse)，又称为语法分析，其作用是将上一步生成的token数据，根据语法规则转为AST。")])]),a._v(" "),v("h2",{attrs:{id:"_2-生成字节码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-生成字节码"}},[a._v("#")]),a._v(" 2. 生成字节码")]),a._v(" "),v("p",[a._v("chrome为了优化机器码内存占用问题，引入字节码。字节码就是介于AST和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。")]),a._v(" "),v("h2",{attrs:{id:"_3-执行代码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-执行代码"}},[a._v("#")]),a._v(" 3. 执行代码")]),a._v(" "),v("p",[a._v("解释器逐条执行代码，在执行字节码的过程中，如果发现热点代码，比如一段代码被重复执行的多次，则编译器将会把该段热点字节码编译成高效的机器码。")]),a._v(" "),v("h1",{attrs:{id:"即时编译-jit"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#即时编译-jit"}},[a._v("#")]),a._v(" 即时编译(JIT)")]),a._v(" "),v("p",[a._v("具体到V8，就是指解释器Ignition在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan编译器便登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。"),v("br"),a._v("\n虽然在V8诞生之初，也出现过一系列针对V8而专门优化JavaScript性能的方案，比如隐藏类、内联缓存等概念都是那时候提出来的。不过随着V8的架构调整，你越来越不需要这些微优化策略了，相反，对于优化JavaScript执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：提升单次脚本的执行速度，避免JavaScript的长任务霸占主线程，这样可以使得页面快速响应交互；避免大的内联脚本， 因为在解析HTML的过程中，解析和编译也会占用主线程；减少JavaScript文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。")])])}),[],!1,null,null,null);t.default=r.exports}}]);