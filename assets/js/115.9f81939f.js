(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{471:function(t,a,s){"use strict";s.r(a);var r=s(42),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"数据包大小对网络的影响-mtu-与-mss-的奥秘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据包大小对网络的影响-mtu-与-mss-的奥秘"}},[t._v("#")]),t._v(" 数据包大小对网络的影响 —— MTU 与 MSS 的奥秘")]),t._v(" "),s("h2",{attrs:{id:"最大传输单元-maximum-transmission-unit-mtu"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最大传输单元-maximum-transmission-unit-mtu"}},[t._v("#")]),t._v(" 最大传输单元（Maximum Transmission Unit, MTU）")]),t._v(" "),s("p",[t._v("数据链路层传输的帧大小是有限制的，不能把一个太大的包直接塞给链路层，这个限制被称为「最大传输单元（Maximum Transmission Unit, MTU）」\n下图是以太网的帧格式，以太网的帧最小的帧是 64 字节，除去 14 字节头部和 4 字节 CRC 字段，有效荷载最小为 46 字节。最大的帧是 1518 字节，除去 14 字节头部和 4 字节 CRC，有效荷载最大为 1500，这个值就是以太网的 MTU。因此如果传输 100KB 的数据，至少需要 （100 * 1024 / 1500) = 69 个以太网帧。")]),t._v(" "),s("h2",{attrs:{id:"tcp-最大段大小-max-segment-size-mss"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-最大段大小-max-segment-size-mss"}},[t._v("#")]),t._v(" TCP 最大段大小（Max Segment Size，MSS）")]),t._v(" "),s("p",[t._v("TCP 为了避免被发送方分片，会主动把数据分割成小段再交给网络层，最大的分段大小称之为 MSS（Max Segment Size）。")]),t._v(" "),s("h1",{attrs:{id:"支撑-tcp-协议的基石-剖析首部字段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#支撑-tcp-协议的基石-剖析首部字段"}},[t._v("#")]),t._v(" 支撑 TCP 协议的基石 —— 剖析首部字段")]),t._v(" "),s("h2",{attrs:{id:"源端口号、目标端口号"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#源端口号、目标端口号"}},[t._v("#")]),t._v(" 源端口号、目标端口号")]),t._v(" "),s("h1",{attrs:{id:"序列号-sequence-number"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#序列号-sequence-number"}},[t._v("#")]),t._v(" 序列号（Sequence number）")]),t._v(" "),s("p",[t._v("TCP 是面向字节流的协议，通过 TCP 传输的字节流的每个字节都分配了序列号，序列号（Sequence number）指的是本报文段第一个字节的序列号。")]),t._v(" "),s("h2",{attrs:{id:"确认号"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#确认号"}},[t._v("#")]),t._v(" 确认号")]),t._v(" "),s("p",[t._v("TCP 使用确认号（Acknowledgment number, ACK）来告知对方下一个期望接收的序列号，小于此确认号的所有字节都已经收到。")]),t._v(" "),s("h2",{attrs:{id:"tcp-flags"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-flags"}},[t._v("#")]),t._v(" TCP Flags")]),t._v(" "),s("p",[t._v("最常见的有下面这几个：\n1、SYN（Synchronize）：用于发起连接数据包同步双方的初始序列号\n2、ACK（Acknowledge）：确认数据包\n3、RST（Reset）：这个标记用来强制断开连接，通常是之前建立的连接已经不在了、包不合法、或者实在无能为力处理\n4、FIN（Finish）：通知对方我发完了所有数据，准备断开连接，后面我不会再发数据包给你了。\n5、PSH（Push）：告知对方这些数据包收到以后应该马上交给上层应用，不能缓存起来")]),t._v(" "),s("h2",{attrs:{id:"窗口大小"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#窗口大小"}},[t._v("#")]),t._v(" 窗口大小")]),t._v(" "),s("h2",{attrs:{id:"可选项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可选项"}},[t._v("#")]),t._v(" 可选项")]),t._v(" "),s("p",[t._v("常用的选项有以下几个：\n1、MSS：最大段大小选项，是 TCP 允许的从对方接收的最大报文段\n2、SACK：选择确认选项\n3、Window Scale：窗口缩放选项")]),t._v(" "),s("h1",{attrs:{id:"tcp-概述-可靠的、面向连接的、基于字节流、全双工的协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-概述-可靠的、面向连接的、基于字节流、全双工的协议"}},[t._v("#")]),t._v(" TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议")]),t._v(" "),s("h2",{attrs:{id:"_0x01-tcp-是面向连接的协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0x01-tcp-是面向连接的协议"}},[t._v("#")]),t._v(" 0x01 TCP 是面向连接的协议")]),t._v(" "),s("p",[t._v("一开始学习 TCP 的时候，我们就被告知 TCP 是面向连接的协议，那什么是面向连接，什么是无连接呢？\n1、面向连接（connection-oriented）：面向连接的协议要求正式发送数据之前需要通过「握手」建立一个逻辑连接，结束通信时也是通过有序的四次挥手来断开连接。\n2、无连接（connectionless）：无连接的协议则不需要")]),t._v(" "),s("h2",{attrs:{id:"_0x02-tcp-协议是可靠的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0x02-tcp-协议是可靠的"}},[t._v("#")]),t._v(" 0x02 TCP 协议是可靠的")]),t._v(" "),s("p",[t._v("IP 是一种无连接、不可靠的协议：它尽最大可能将数据报从发送者传输给接收者，但并不保证包到达的顺序会与它们被传输的顺序一致，也不保证包是否重复，甚至都不保证包是否会达到接收者。\nTCP 要想在 IP 基础上构建可靠的传输层协议，必须有一个复杂的机制来保障可靠性。 主要有下面几个方面：\n1、对每个包提供校验和\n2、包的序列号解决了接收数据的乱序、重复问题\n3、超时重传\n4、流量控制、拥塞控制")]),t._v(" "),s("h2",{attrs:{id:"_0x03-tcp-是面向字节流的协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0x03-tcp-是面向字节流的协议"}},[t._v("#")]),t._v(" 0x03 TCP 是面向字节流的协议")]),t._v(" "),s("p",[t._v("TCP 是一种字节流（byte-stream）协议，流的含义是没有固定的报文边界。")]),t._v(" "),s("h2",{attrs:{id:"_0x04-tcp-是全双工的协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0x04-tcp-是全双工的协议"}},[t._v("#")]),t._v(" 0x04 TCP 是全双工的协议")]),t._v(" "),s("p",[t._v("在 TCP 中发送端和接收端可以是客户端/服务端，也可以是服务器/客户端，通信的双方在任意时刻既可以是接收数据也可以是发送数据，每个方向的数据流都独立管理序列号、滑动窗口大小、MSS 等信息。")]),t._v(" "),s("h1",{attrs:{id:"tcp-恋爱史第一步-从三次握手说起"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-恋爱史第一步-从三次握手说起"}},[t._v("#")]),t._v(" TCP 恋爱史第一步 —— 从三次握手说起")]),t._v(" "),s("h2",{attrs:{id:"三次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),s("p",[t._v("1、客户端发送的一个段是 SYN 报文，这个报文只有 SYN 标记被置位。SYN 报文不携带数据，但是它占用一个序号，下次发送数据序列号要加一。客户端会随机选择一个数字作为初始序列号（ISN）\n凡是消耗序列号的 TCP 报文段，一定需要对端确认。如果这个段没有收到确认，会一直重传直到达到指定的次数为止。\n2、服务端收到客户端的 SYN 段以后，将 SYN 和 ACK 标记都置位\nSYN 标记的作用与步骤 1 中的一样，也是同步服务端生成的初始序列号。ACK 用来告知发送端之前发送的 SYN 段已经收到了，「确认号」字段指定了发送端下次发送段的序号，这里等于客户端 ISN 加一。 与前面类似 SYN + ACK 端虽然没有携带数据，但是因为 SYN 段需要被确认，所以它也要消耗一个序列号。\n3、客户端发送三次握手最后一个 ACK 段，这个 ACK 段用来确认收到了服务端发送的 SYN 段。因为这个 ACK 段不携带任何数据，且不需要再被确认，这个 ACK 段不消耗任何序列号。\n除了交换彼此的初始序列号，三次握手的另一个重要作用是交换一些辅助信息，比如最大段大小（MSS）、窗口大小（Win）、窗口缩放因子（WS)、是否支持选择确认（SACK_PERM）等，这些都会在后面的文章中重点介绍。")]),t._v(" "),s("h2",{attrs:{id:"三次握手的状态变化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三次握手的状态变化"}},[t._v("#")]),t._v(" 三次握手的状态变化")]),t._v(" "),s("p",[t._v("对于客户端而言：\n1、初始的状态是处于 CLOSED 状态。CLOSED 并不是一个真实的状态，而是一个假想的起点和终点。\n2、客户端调用 connect 以后会发送 SYN 同步报文给服务端，然后进入 SYN-SENT 阶段，客户端将保持这个阶段直到它收到了服务端的确认包。\n3、如果在 SYN-SENT 状态收到了服务端的确认包，它将发送确认服务端 SYN 报文的 ACK 包，同时进入 ESTABLISHED 状态，表明自己已经准备好发送数据。\n对于服务端而言：\n1、初始状态同样是 CLOSED 状态\n2、在执行 bind、listen 调用以后进入 LISTEN状态，等待客户端连接。\n3、当收到客户端的 SYN 同步报文以后，会回复确认同时发送自己的 SYN 同步报文，这时服务端进入 SYN-RCVD 阶段等待客户端的确认。\n4、当收到客户端的确认报文以后，进入ESTABLISHED 状态。这时双方可以互相发数据了。")]),t._v(" "),s("h1",{attrs:{id:"tcp-ip-协议产生的历史背景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip-协议产生的历史背景"}},[t._v("#")]),t._v(" TCP/IP 协议产生的历史背景")]),t._v(" "),s("h2",{attrs:{id:"应用层-application-layer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用层-application-layer"}},[t._v("#")]),t._v(" 应用层（Application Layer）")]),t._v(" "),s("p",[t._v("应用层的本质是规定了应用程序之间如何相互传递报文， 以 HTTP 协议为例，它规定了\n1、报文的类型，是请求报文还是响应报文\n2、报文的语法，报文分为几段，各段是什么含义、用什么分隔，每个部分的每个字段什么什么含义\n3、进程应该以什么样的时序发送报文和处理响应报文")]),t._v(" "),s("h2",{attrs:{id:"传输层-transport-layer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#传输层-transport-layer"}},[t._v("#")]),t._v(" 传输层（Transport Layer）")]),t._v(" "),s("p",[t._v("传输层的作用是为两台主机之间的「应用进程」提供端到端的逻辑通信，相隔几千公里的两台主机的进程就好像在直接通信一样。\n虽然是叫传输层，但是并不是将数据包从一台主机传送到另一台，而是对「传输行为进行控制」，这本小册介绍的主要内容 TCP 协议就被称为传输控制协议（Transmission Control Protocol），为下面两层协议提供数据包的重传、流量控制、拥塞控制等。")]),t._v(" "),s("h2",{attrs:{id:"网络互连层-internet-layer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络互连层-internet-layer"}},[t._v("#")]),t._v(" 网络互连层（Internet Layer）")]),t._v(" "),s("p",[t._v("网络互连层提供了主机到主机的通信，将传输层产生的的数据包封装成分组数据包发送到目标主机，并提供路由选择的能力。IP 协议是网络层的主要协议，TCP 和 UDP 都是用 IP 协议作为网络层协议。这一层的主要作用是给包加上源地址和目标地址，将数据包传送到目标地址。IP 协议是一个无连接的协议，也不具备重发机制，这也是 TCP 协议复杂的原因之一就是基于了这样一个「不靠谱」的协议。")]),t._v(" "),s("h2",{attrs:{id:"网络访问层-network-access-layer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络访问层-network-access-layer"}},[t._v("#")]),t._v(" 网络访问层（Network Access Layer）")]),t._v(" "),s("p",[t._v("网络访问层也有说法叫做网络接口层，以太网、Wifi、蓝牙工作在这一层，网络访问层提供了主机连接到物理网络需要的硬件和相关的协议。")])])}),[],!1,null,null,null);a.default=e.exports}}]);