(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{434:function(e,r,t){"use strict";t.r(r);var s=t(42),o=Object(s.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" 🤔Promise")]),e._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#构造函数"}},[e._v("构造函数")])]),t("li",[t("a",{attrs:{href:"#静态方法"}},[e._v("静态方法")]),t("ul",[t("li",[t("a",{attrs:{href:"#promise-all-iterable"}},[e._v("Promise.all(iterable)")])]),t("li",[t("a",{attrs:{href:"#promise-allsettled-iterable"}},[e._v("Promise.allSettled(iterable)")])]),t("li",[t("a",{attrs:{href:"#promise-any-iterable"}},[e._v("Promise.any(iterable)")])]),t("li",[t("a",{attrs:{href:"#promise-race-iterable"}},[e._v("Promise.race(iterable)")])]),t("li",[t("a",{attrs:{href:"#promise-reject-reason"}},[e._v("Promise.reject(reason)")])]),t("li",[t("a",{attrs:{href:"#promise-resolve-value"}},[e._v("Promise.resolve(value)")])])])]),t("li",[t("a",{attrs:{href:"#promise-原型"}},[e._v("Promise 原型")])]),t("li",[t("a",{attrs:{href:"#属性"}},[e._v("属性")]),t("ul",[t("li",[t("a",{attrs:{href:"#promise-prototype-constructor"}},[e._v("Promise.prototype.constructor")])])])]),t("li",[t("a",{attrs:{href:"#方法"}},[e._v("方法")]),t("ul",[t("li",[t("a",{attrs:{href:"#promise-prototype-catch-onrejected"}},[e._v("Promise.prototype.catch(onRejected)")])]),t("li",[t("a",{attrs:{href:"#promise-prototype-then-onfulfilled-onrejected"}},[e._v("Promise.prototype.then(onFulfilled, onRejected)")])]),t("li",[t("a",{attrs:{href:"#promise-prototype-finally-onfinally"}},[e._v("Promise.prototype.finally(onFinally)")])])])])])]),t("p"),e._v(" "),t("h2",{attrs:{id:"构造函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[e._v("#")]),e._v(" 构造函数")]),e._v(" "),t("p",[t("code",[e._v("Promise()")]),e._v("\n创建一个新的 Promise 对象。该构造函数主要用于包装还没有添加 promise 支持的函数。")]),e._v(" "),t("h2",{attrs:{id:"静态方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态方法"}},[e._v("#")]),e._v(" 静态方法")]),e._v(" "),t("h3",{attrs:{id:"promise-all-iterable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-all-iterable"}},[e._v("#")]),e._v(" "),t("code",[e._v("Promise.all(iterable)")])]),e._v(" "),t("p",[e._v("这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。")]),e._v(" "),t("h3",{attrs:{id:"promise-allsettled-iterable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-allsettled-iterable"}},[e._v("#")]),e._v(" "),t("code",[e._v("Promise.allSettled(iterable)")])]),e._v(" "),t("p",[e._v("等到所有promises都已敲定（settled）（每个promise都已兑现（fulfilled）或已拒绝（rejected））。\n返回一个promise，该promise在所有promise完成后完成。并带有一个对象数组，每个对象对应每个promise的结果。")]),e._v(" "),t("h3",{attrs:{id:"promise-any-iterable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-any-iterable"}},[e._v("#")]),e._v(" "),t("code",[e._v("Promise.any(iterable)")])]),e._v(" "),t("p",[e._v("接收一个Promise对象的集合，当其中的一个promise成功，就返回那个成功的promise的值。")]),e._v(" "),t("h3",{attrs:{id:"promise-race-iterable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-race-iterable"}},[e._v("#")]),e._v(" "),t("code",[e._v("Promise.race(iterable)")])]),e._v(" "),t("p",[e._v("当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。")]),e._v(" "),t("h3",{attrs:{id:"promise-reject-reason"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-reject-reason"}},[e._v("#")]),e._v(" "),t("code",[e._v("Promise.reject(reason)")])]),e._v(" "),t("p",[e._v("返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法")]),e._v(" "),t("h3",{attrs:{id:"promise-resolve-value"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-resolve-value"}},[e._v("#")]),e._v(" "),t("code",[e._v("Promise.resolve(value)")])]),e._v(" "),t("p",[e._v("返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象)，返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果您不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。")]),e._v(" "),t("h2",{attrs:{id:"promise-原型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-原型"}},[e._v("#")]),e._v(" Promise 原型")]),e._v(" "),t("h2",{attrs:{id:"属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#属性"}},[e._v("#")]),e._v(" 属性")]),e._v(" "),t("h3",{attrs:{id:"promise-prototype-constructor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-constructor"}},[e._v("#")]),e._v(" "),t("code",[e._v("Promise.prototype.constructor")])]),e._v(" "),t("p",[e._v("返回被创建的实例函数.  默认为 Promise 函数.")]),e._v(" "),t("h2",{attrs:{id:"方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[e._v("#")]),e._v(" 方法")]),e._v(" "),t("h3",{attrs:{id:"promise-prototype-catch-onrejected"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-catch-onrejected"}},[e._v("#")]),e._v(" "),t("code",[e._v("Promise.prototype.catch(onRejected)")])]),e._v(" "),t("p",[e._v("添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise。当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果.")]),e._v(" "),t("h3",{attrs:{id:"promise-prototype-then-onfulfilled-onrejected"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-then-onfulfilled-onrejected"}},[e._v("#")]),e._v(" "),t("code",[e._v("Promise.prototype.then(onFulfilled, onRejected)")])]),e._v(" "),t("p",[e._v("添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve.")]),e._v(" "),t("h3",{attrs:{id:"promise-prototype-finally-onfinally"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-finally-onfinally"}},[e._v("#")]),e._v(" "),t("code",[e._v("Promise.prototype.finally(onFinally)")])]),e._v(" "),t("p",[e._v("添加一个事件处理回调于当前promise对象，并且在原promise对象解析完毕后，返回一个新的promise对象。回调会在当前promise运行完毕后被调用，无论当前promise的状态是完成(fulfilled)还是失败(rejected)")])])}),[],!1,null,null,null);r.default=o.exports}}]);