(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{468:function(a,e,t){"use strict";t.r(e);var r=t(42),v=Object(r.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"http缓存方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http缓存方案"}},[a._v("#")]),a._v(" ⭐️HTTP缓存方案")]),a._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#缓存位置"}},[a._v("缓存位置")]),t("ul",[t("li",[t("a",{attrs:{href:"#service-worker"}},[a._v("Service Worker")])]),t("li",[t("a",{attrs:{href:"#memory-cache"}},[a._v("Memory Cache")])]),t("li",[t("a",{attrs:{href:"#disk-cache"}},[a._v("Disk Cache")])]),t("li",[t("a",{attrs:{href:"#push-cache"}},[a._v("Push Cache")])]),t("li",[t("a",{attrs:{href:"#网络请求"}},[a._v("网络请求")])])])]),t("li",[t("a",{attrs:{href:"#缓存策略"}},[a._v("缓存策略")]),t("ul",[t("li",[t("a",{attrs:{href:"#强缓存"}},[a._v("强缓存")])]),t("li",[t("a",{attrs:{href:"#协商缓存"}},[a._v("协商缓存")])])])])])]),t("p"),a._v(" "),t("p",[a._v("缓存可以说是性能优化中简单高效的一种优化方式了，它可以显著减少网络传输所带来的损耗。")]),a._v(" "),t("p",[a._v("对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。")]),a._v(" "),t("h2",{attrs:{id:"缓存位置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存位置"}},[a._v("#")]),a._v(" 缓存位置")]),a._v(" "),t("p",[a._v("从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络")]),a._v(" "),t("ol",[t("li",[a._v("Service Worker")]),a._v(" "),t("li",[a._v("Memory Cache")]),a._v(" "),t("li",[a._v("Disk Cache")]),a._v(" "),t("li",[a._v("Push Cache")]),a._v(" "),t("li",[a._v("网络请求")])]),a._v(" "),t("h3",{attrs:{id:"service-worker"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service-worker"}},[a._v("#")]),a._v(" Service Worker")]),a._v(" "),t("p",[a._v("Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。")]),a._v(" "),t("p",[a._v("当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。")]),a._v(" "),t("h3",{attrs:{id:"memory-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#memory-cache"}},[a._v("#")]),a._v(" Memory Cache")]),a._v(" "),t("p",[a._v("Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。")]),a._v(" "),t("p",[a._v("当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存，那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？")]),a._v(" "),t("p",[a._v("先说结论，这是不可能的。首先计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。内存中其实可以存储大部分的文件，比如说 JSS、HTML、CSS、图片等等。但是浏览器会把哪些文件丢进内存这个过程就很玄学了，我查阅了很多资料都没有一个定论。")]),a._v(" "),t("p",[a._v("当然，我通过一些实践和猜测也得出了一些结论：")]),a._v(" "),t("ul",[t("li",[a._v("对于大文件来说，大概率是不存储在内存中的，反之优先")]),a._v(" "),t("li",[a._v("当前系统内存使用率高的话，文件优先存储进硬盘")])]),a._v(" "),t("h3",{attrs:{id:"disk-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#disk-cache"}},[a._v("#")]),a._v(" Disk Cache")]),a._v(" "),t("p",[a._v("Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。")]),a._v(" "),t("p",[a._v("在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。")]),a._v(" "),t("h3",{attrs:{id:"push-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#push-cache"}},[a._v("#")]),a._v(" Push Cache")]),a._v(" "),t("p",[a._v("Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。")]),a._v(" "),t("p",[a._v("Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及，但是 HTTP/2 将会是日后的一个趋势。这里推荐阅读 HTTP/2 push is tougher than I thought 这篇文章，但是内容是英文的，我翻译一下文章中的几个结论，有能力的同学还是推荐自己阅读")]),a._v(" "),t("ul",[t("li",[a._v("所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好")]),a._v(" "),t("li",[a._v("可以推送 no-cache 和 no-store 的资源")]),a._v(" "),t("li",[a._v("一旦连接被关闭，Push Cache 就被释放")]),a._v(" "),t("li",[a._v("多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存")]),a._v(" "),t("li",[a._v("Push Cache 中的缓存只能被使用一次")]),a._v(" "),t("li",[a._v("浏览器可以拒绝接受已经存在的资源推送")]),a._v(" "),t("li",[a._v("你可以给其他域名推送资源")])]),a._v(" "),t("h3",{attrs:{id:"网络请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络请求"}},[a._v("#")]),a._v(" 网络请求")]),a._v(" "),t("p",[a._v("如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。")]),a._v(" "),t("p",[a._v("那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，接下来我们就来学习缓存策略这部分的内容。")]),a._v(" "),t("h2",{attrs:{id:"缓存策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存策略"}},[a._v("#")]),a._v(" 缓存策略")]),a._v(" "),t("h3",{attrs:{id:"强缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[a._v("#")]),a._v(" 强缓存")]),a._v(" "),t("p",[a._v("浏览器进行资源请求时，会判断response headers是否命中强缓存，如果命中，直接从本地读取缓存，不会向服务器发送请求。")]),a._v(" "),t("h4",{attrs:{id:"cache-control-http-1-1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache-control-http-1-1"}},[a._v("#")]),a._v(" Cache-Control HTTP/1.1")]),a._v(" "),t("ul",[t("li",[a._v("max-age（单位为s）：指定设置缓存最大的有效时间，定义的是时间长短；")]),a._v(" "),t("li",[a._v("s-maxage（单位为s）：同max-age，只用于共享缓存（比如CDN缓存）；")]),a._v(" "),t("li",[a._v("public：指定响应会被缓存，并且在多用户间共享；")]),a._v(" "),t("li",[a._v("private：响应只作为私有的缓存（见下图），不能在用户间共享；")]),a._v(" "),t("li",[a._v("no-cache：指定不缓存响应，表明资源不进行缓存.跳过强缓存阶段直接进入协商缓存阶段；")]),a._v(" "),t("li",[a._v("no-store：绝对禁止缓存；")])]),a._v(" "),t("h4",{attrs:{id:"expires-http-1-0"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#expires-http-1-0"}},[a._v("#")]),a._v(" Expires HTTP/1.0")]),a._v(" "),t("p",[a._v("缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点（绝对时间）。")]),a._v(" "),t("h3",{attrs:{id:"协商缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[a._v("#")]),a._v(" 协商缓存")]),a._v(" "),t("p",[a._v("当强缓存没有命中时，会发送请求到服务端，判断协商缓存是否命中，如果命中，服务器将请求返回，不会返回资源，告诉浏览器从本地读取缓存。如何不命中，服务器直接返回资源。")]),a._v(" "),t("h4",{attrs:{id:"last-modified-if-moified-since"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-if-moified-since"}},[a._v("#")]),a._v(" Last-Modified/If-Moified-Since")]),a._v(" "),t("ul",[t("li",[a._v("Last-Modified：表示为为实体头部部分，response返回，表示为资源的最后更新时间 ；")]),a._v(" "),t("li",[a._v("If-Modified-Since：即Last-Modified，通过比较两次的时间判断，资源在请求期间是否有修改，假如没有修改，则命中协商缓存，浏览器从缓存中读取资源，如果没有命中，资源有过修改，返回新的Last-Modified时间和服务器资源；")])]),a._v(" "),t("h4",{attrs:{id:"etag-if-none-match"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#etag-if-none-match"}},[a._v("#")]),a._v(" ETag/If-None-Match")]),a._v(" "),t("ul",[t("li",[a._v("ETag：为相应头部字段，表示资源内容的唯一标识，随服务器response返回；")]),a._v(" "),t("li",[a._v("If-None-Match： 即ETag，服务器比较请求头中的If-None-Match和当前资源中的etag是否一致，来判断资源是否修改过，如果没有修改，则命中缓存，浏览器从缓存中读取资源，如果修改过，服务器会返回新的etag，并返回资源；")])])])}),[],!1,null,null,null);e.default=v.exports}}]);